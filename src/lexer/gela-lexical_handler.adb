------------------------------------------------------------------------------
--                        G E L A   G R A M M A R S                         --
--        Library for dealing with grammars for for Gela project,           --
--                        a portable Ada compiler                           --
--                        http://gela.ada-ru.org/                           --
--                     - - - - - - - - - - - - - - -                        --
--              Read copyright and license in gela.ads file                 --
------------------------------------------------------------------------------

with League.Characters;
with League.Strings;

with Gela.Lexical_Types; use Gela.Lexical_Types;

package body Gela.Lexical_Handler is

   function To_Token
     (X : League.Strings.Universal_String)
      return Gela.Lexical_Types.Token_Kind;
   --  Convert folded text to token

   subtype Hash_Value is Positive range 2 + 2 * 6 .. 12 + 3 * 115;

   function Hash (W : League.Strings.Universal_String) return Hash_Value;

   Map : constant array (Gela.Scanner_Types.Rule_Index range 1 .. 27) of
     Gela.Lexical_Types.Token_Kind :=
       (1 => Arrow_Token, 2 => Double_Dot_Token, 3 => Double_Star_Token,
        4 => Assignment_Token, 5 => Inequality_Token,
        6 => Greater_Or_Equal_Token, 7 => Less_Or_Equal_Token,
        8 => Left_Label_Token, 9 => Right_Label_Token, 10 => Box_Token,
        11 => Ampersand_Token, 12 => Apostrophe_Token,
        13 => Left_Parenthesis_Token, 14 => Right_Parenthesis_Token,
        15 => Star_Token, 16 => Plus_Token, 17 => Comma_Token,
        18 => Hyphen_Token, 19 => Dot_Token, 20 => Slash_Token,
        21 => Colon_Token, 22 => Semicolon_Token, 23 => Less_Token,
        24 => Equal_Token, 25 => Greater_Token, 26 => Vertical_Line_Token,
        27 => Vertical_Line_Token);

   Id : constant Gela.Lexical_Types.Token_Kind :=
     Gela.Lexical_Types.Identifier_Token;

   --  generated by gperf -m 100
   Word_Map : constant array (Hash_Value range 22 .. 114)
     of Gela.Lexical_Types.Token_Kind :=
       (Gela.Lexical_Types.Else_Token,
        Gela.Lexical_Types.At_Token,
        Gela.Lexical_Types.Task_Token,
        Gela.Lexical_Types.Then_Token,
        Gela.Lexical_Types.Not_Token,
        Gela.Lexical_Types.Range_Token,
        Gela.Lexical_Types.Abs_Token,
        Gela.Lexical_Types.Renames_Token,
        Gela.Lexical_Types.Return_Token,
        Gela.Lexical_Types.End_Token,
        Gela.Lexical_Types.Terminate_Token,
        Gela.Lexical_Types.Case_Token,
        Gela.Lexical_Types.Xor_Token,
        Gela.Lexical_Types.Abstract_Token,
        Gela.Lexical_Types.Synchronized_Token,
        Gela.Lexical_Types.Reverse_Token,
        Gela.Lexical_Types.And_Token,
        Gela.Lexical_Types.Exception_Token,
        Gela.Lexical_Types.Constant_Token,
        Gela.Lexical_Types.Declare_Token,
        Gela.Lexical_Types.Access_Token,
        Gela.Lexical_Types.Record_Token,
        Gela.Lexical_Types.Accept_Token,
        Gela.Lexical_Types.Is_Token,
        Gela.Lexical_Types.In_Token,
        Gela.Lexical_Types.Type_Token,
        Gela.Lexical_Types.Entry_Token,
        Gela.Lexical_Types.Separate_Token,
        Gela.Lexical_Types.Or_Token,
        Gela.Lexical_Types.Requeue_Token,
        Gela.Lexical_Types.Do_Token,
        Gela.Lexical_Types.Select_Token,
        Gela.Lexical_Types.When_Token,
        Gela.Lexical_Types.Exit_Token,
        Gela.Lexical_Types.Array_Token,
        Gela.Lexical_Types.Raise_Token,
        Gela.Lexical_Types.Out_Token,
        Gela.Lexical_Types.Package_Token,
        Gela.Lexical_Types.Interface_Token,
        Gela.Lexical_Types.Pragma_Token,
        Gela.Lexical_Types.Delta_Token,
        Gela.Lexical_Types.Use_Token,
        Gela.Lexical_Types.Digits_Token,
        Gela.Lexical_Types.Abort_Token,
        Gela.Lexical_Types.Tagged_Token,
        Gela.Lexical_Types.Some_Token,
        Gela.Lexical_Types.Aliased_Token,
        Gela.Lexical_Types.Elsif_Token,
        Gela.Lexical_Types.Subtype_Token,
        Id,
        Gela.Lexical_Types.Generic_Token,
        Gela.Lexical_Types.For_Token,
        Gela.Lexical_Types.Function_Token,
        Id,
        Gela.Lexical_Types.Mod_Token,
        Gela.Lexical_Types.Null_Token,
        Gela.Lexical_Types.Delay_Token,
        Gela.Lexical_Types.Private_Token,
        Id, Id,
        Gela.Lexical_Types.All_Token,
        Gela.Lexical_Types.Procedure_Token,
        Gela.Lexical_Types.New_Token,
        Gela.Lexical_Types.While_Token,
        Id,
        Gela.Lexical_Types.With_Token,
        Gela.Lexical_Types.Protected_Token,
        Gela.Lexical_Types.Others_Token,
        Id,
        Gela.Lexical_Types.If_Token,
        Gela.Lexical_Types.Goto_Token,
        Gela.Lexical_Types.Of_Token,
        Gela.Lexical_Types.Until_Token,
        Gela.Lexical_Types.Body_Token,
        Gela.Lexical_Types.Overriding_Token,
        Id, Id, Id, Id, Id,
        Gela.Lexical_Types.Limited_Token,
        Id,
        Gela.Lexical_Types.Begin_Token,
        Gela.Lexical_Types.Loop_Token,
        Id, Id, Id, Id, Id, Id, Id, Id,
        Gela.Lexical_Types.Rem_Token);

   type Universal_String_Array is array (Hash_Value range 22 .. 114)
     of League.Strings.Universal_String;
   type Universal_String_Array_Access is access all Universal_String_Array;

   Word_List : Universal_String_Array_Access;

   -----------------------
   -- Character_Literal --
   -----------------------

   overriding procedure Character_Literal
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Length : constant Positive := Scanner.Get_Token_Length;
      Value  : Gela.Lexical_Types.Token;
      Text   : constant League.Strings.Universal_String := Scanner.Get_Text;
      Symbol : constant Gela.Lexical_Types.Symbol := Self.Symbols.Get (Text);
   begin
      Scanner.Set_Start_Condition (Gela.Scanner_Types.Allow_Char);
      Token := Gela.Lexical_Types.Character_Literal_Token;
      Skip := False;

      Value :=
        (Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Length - 1,
         Separator => Self.Separator,
         Kind      => Token,
         Symbol    => Symbol);

      Self.Output.New_Token (Value);

      Self.Last := Self.Last + Length;
      Self.Separator := Self.Last;
      Self.Last_Token := Token;
   end Character_Literal;

   -------------
   -- Comment --
   -------------

   overriding procedure Comment
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      pragma Unreferenced (Token);
      Length : constant Positive := Scanner.Get_Token_Length;
   begin
      Skip := True;
      Self.Comment := Self.Last;
      Self.Last := Self.Last + Length;
   end Comment;

   ---------------
   -- Delimiter --
   ---------------

   overriding procedure Delimiter
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean)
   is
      Length : constant Positive := Scanner.Get_Token_Length;
      Value : Gela.Lexical_Types.Token;
      Text   : League.Strings.Universal_String;
      Symbol : Gela.Lexical_Types.Symbol;
   begin
      Text.Append ('"');
      Text.Append (Scanner.Get_Text);
      Text.Append ('"');

      Self.Symbols.Fetch (Text, Symbol);

      Scanner.Set_Start_Condition (Gela.Scanner_Types.Allow_Char);
      Token := Map (Rule);
      Skip := False;

      Value :=
        (Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Length - 1,
         Separator => Self.Separator,
         Kind      => Token,
         Symbol    => Symbol);

      Self.Output.New_Token (Value);

      Self.Last := Self.Last + Length;
      Self.Separator := Self.Last;
      Self.Last_Token := Token;
   end Delimiter;

   -----------
   -- Error --
   -----------

   overriding procedure Error
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);

      Length : constant Positive := Scanner.Get_Token_Length;
      Value        : Gela.Lexical_Types.Token;
   begin
      Token := Gela.Lexical_Types.Error;
      Skip := True;

      Value :=
        (Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Length - 1,
         Separator => Self.Separator,
         Kind      => Token,
         Symbol    => 0);

      Self.Output.New_Token (Value);

      Self.Last := Self.Last + Length;
      Self.Last_Token := Token;
   end Error;

   ----------
   -- Hash --
   ----------

   function Hash (W : League.Strings.Universal_String) return Hash_Value is
      X : constant array (Wide_Wide_Character range 'a' .. 'y') of Positive :=
        (13,  51,  17, 11,   6,  52,  41,  38,  37, 115,   6,  33,  51,
         7,  39,  29,  29,   9,   6,   8,  48,  15,  37, 13,  29);

      function Y (Z : League.Characters.Universal_Character) return Positive;

      function Y (Z : League.Characters.Universal_Character) return Positive is
         Val : constant Wide_Wide_Character := Z.To_Wide_Wide_Character;
      begin
         if Val in X'Range then
            return X (Val);
         else
            return 115;
         end if;
      end Y;
      Length : constant Positive := W.Length;
      Result : Positive := Length;     --  2 .. 12
   begin
      if Length > 2 then
         Result := Result + Y (W.Element (3));  --  6 .. 115
      end if;

      Result := Result + Y (W.Element (1));  --  6 .. 115

      Result := Result + Y (W.Element (Length));  --  6 .. 115

      return Result;
   end Hash;

   ----------------
   -- Identifier --
   ----------------

   overriding procedure Identifier
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);

      Length : constant Positive := Scanner.Get_Token_Length;
      Text   : constant League.Strings.Universal_String := Scanner.Get_Text;
      Value  : Gela.Lexical_Types.Token;
      Symbol : Gela.Lexical_Types.Symbol;
   begin
      Self.Symbols.Fetch (Text, Symbol);
      Token := To_Token (Self.Symbols.Folded (Symbol));
      Skip := False;

      if Self.Last_Token = Gela.Lexical_Types.Apostrophe_Token and
        Token /= Gela.Lexical_Types.Range_Token
      then
         Token := Id;
      end if;

      if Token = Id then
         Scanner.Set_Start_Condition (Gela.Scanner_Types.INITIAL);
      else
         Scanner.Set_Start_Condition (Gela.Scanner_Types.Allow_Char);
      end if;

      Value :=
        (Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Length - 1,
         Separator => Self.Separator,
         Kind      => Token,
         Symbol    => Symbol);

      Self.Output.New_Token (Value);

      Self.Last := Self.Last + Length;
      Self.Separator := Self.Last;
      Self.Last_Token := Token;
   end Identifier;

   ----------------
   -- Initialize --
   ----------------

   procedure Initialize is
      function "+"
        (Left : Wide_Wide_String)
         return League.Strings.Universal_String renames
        League.Strings.To_Universal_String;

      Nil : constant League.Strings.Universal_String :=
        League.Strings.Empty_Universal_String;

   begin
      Word_List := new Universal_String_Array'
        (+"else",
         +"at",
         +"task",
         +"then",
         +"not",
         +"range",
         +"abs",
         +"renames",
         +"return",
         +"end",
         +"terminate",
         +"case",
         +"xor",
         +"abstract",
         +"synchronized",
         +"reverse",
         +"and",
         +"exception",
         +"constant",
         +"declare",
         +"access",
         +"record",
         +"accept",
         +"is",
         +"in",
         +"type",
         +"entry",
         +"separate",
         +"or",
         +"requeue",
         +"do",
         +"select",
         +"when",
         +"exit",
         +"array",
         +"raise",
         +"out",
         +"package",
         +"interface",
         +"pragma",
         +"delta",
         +"use",
         +"digits",
         +"abort",
         +"tagged",
         +"some",
         +"aliased",
         +"elsif",
         +"subtype",
         Nil,
         +"generic",
         +"for",
         +"function",
         Nil,
         +"mod",
         +"null",
         +"delay",
         +"private",
         Nil, Nil,
         +"all",
         +"procedure",
         +"new",
         +"while",
         Nil,
         +"with",
         +"protected",
         +"others",
         Nil,
         +"if",
         +"goto",
         +"of",
         +"until",
         +"body",
         +"overriding",
         Nil, Nil, Nil, Nil, Nil,
         +"limited",
         Nil,
         +"begin",
         +"loop",
         Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil,
         +"rem");
   end Initialize;

   --------------
   -- New_Line --
   --------------

   overriding procedure New_Line
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      pragma Unreferenced (Token);

      Length : constant Positive := Scanner.Get_Token_Length;
      Comment      : Text_Index;
      Value        : Gela.Lexical_Types.Line_Span;
   begin
      Skip := True;

      if Self.Comment >= Self.Line_First then
         Comment := Self.Comment;
      else
         Comment := Self.Last + 1;
      end if;

      Value :=
        (First   => Self.Line_First,
         Last    => Self.Last - 1,
         Comment => Comment);

      Self.Output.New_Line (Value);

      Self.Last := Self.Last + Length;
      Self.Line := Self.Line + 1;
      Self.Line_First := Self.Last;
   end New_Line;

   ---------------------
   -- Numeric_Literal --
   ---------------------

   overriding procedure Numeric_Literal
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Length : constant Positive := Scanner.Get_Token_Length;
      Value : Gela.Lexical_Types.Token;
   begin
      Scanner.Set_Start_Condition (Gela.Scanner_Types.Allow_Char);
      Token := Gela.Lexical_Types.Numeric_Literal_Token;
      Skip := False;

      Value :=
        (Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Length - 1,
         Separator => Self.Separator,
         Kind      => Token,
         Symbol    => 0);

      Self.Output.New_Token (Value);

      Self.Last := Self.Last + Length;
      Self.Separator := Self.Last;
      Self.Last_Token := Token;
   end Numeric_Literal;

   ---------------------------------
   -- Obsolescent_Numeric_Literal --
   ---------------------------------

   overriding procedure Obsolescent_Numeric_Literal
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean) renames Numeric_Literal;

   --------------------------------
   -- Obsolescent_String_Literal --
   --------------------------------

   overriding procedure Obsolescent_String_Literal
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean) renames String_Literal;

   -----------
   -- Space --
   -----------

   overriding procedure Space
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      pragma Unreferenced (Token);
      Length : constant Positive := Scanner.Get_Token_Length;
   begin
      Skip := True;
      Self.Last := Self.Last + Length;
   end Space;

   --------------------
   -- String_Literal --
   --------------------

   overriding procedure String_Literal
     (Self    : not null access Handler;
      Scanner : not null access Gela.Scanners.Scanner'Class;
      Rule    : Gela.Scanner_Types.Rule_Index;
      Token   : out Gela.Lexical_Types.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Length : constant Positive := Scanner.Get_Token_Length;
      Text   : constant League.Strings.Universal_String := Scanner.Get_Text;
      Value  : Gela.Lexical_Types.Token;
      Symbol : constant Gela.Lexical_Types.Symbol := Self.Symbols.Get (Text);
   begin
      Scanner.Set_Start_Condition (Gela.Scanner_Types.Allow_Char);

      Token := Gela.Lexical_Types.String_Literal_Token;
      Skip := False;

      Value :=
        (Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Length - 1,
         Separator => Self.Separator,
         Kind      => Token,
         Symbol    => Symbol);

      Self.Output.New_Token (Value);

      Self.Last := Self.Last + Length;
      Self.Separator := Self.Last;
      Self.Last_Token := Token;
   end String_Literal;

   --------------
   -- To_Token --
   --------------

   function To_Token
     (X : League.Strings.Universal_String)
      return Gela.Lexical_Types.Token_Kind
   is
      use type League.Strings.Universal_String;
      H : Hash_Value;
   begin
      if X.Length in 2 .. 12 then
         H := Hash (X);

         if H in Word_List'Range and then Word_List (H) = X then
            return Word_Map (H);
         else
            return Gela.Lexical_Types.Identifier_Token;
         end if;
      else
         return Gela.Lexical_Types.Identifier_Token;
      end if;
   end To_Token;

end Gela.Lexical_Handler;
