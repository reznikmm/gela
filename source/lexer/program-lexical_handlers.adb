--  Copyright (c) 2019 Maxim Reznik <reznikmm@gmail.com>
--
--  SPDX-License-Identifier: MIT
--  License-Filename: LICENSE
-------------------------------------------------------------

with Ada.Wide_Wide_Characters.Handling;

with Program.Source_Buffers;

package body Program.Lexical_Handlers is

   use all type Program.Scanner_Destinations.Token_Kind;

   subtype Hash_Value is Positive range 2 + 2 * 6 .. 12 + 3 * 115;

   function Hash (W : Wide_Wide_String) return Hash_Value;

   function To_Token
     (X : Wide_Wide_String)
      return Program.Scanner_Destinations.Token_Kind;

   Map : constant array (Program.Scanner_States.Rule_Index range 1 .. 27) of
     Program.Scanner_Destinations.Token_Kind :=
       (1 => Arrow, 2 => Double_Dot, 3 => Double_Star,
        4 => Assignment, 5 => Inequality,
        6 => Greater_Or_Equal, 7 => Less_Or_Equal,
        8 => Left_Label, 9 => Right_Label, 10 => Box,
        11 => Ampersand, 12 => Apostrophe,
        13 => Left_Parenthesis, 14 => Right_Parenthesis,
        15 => Star, 16 => Plus, 17 => Comma,
        18 => Hyphen, 19 => Dot, 20 => Slash,
        21 => Colon, 22 => Semicolon, 23 => Less,
        24 => Equal, 25 => Greater, 26 => Vertical_Line,
        27 => Vertical_Line);

   Id : constant Program.Scanner_Destinations.Token_Kind := Identifier;

   --  generated by gperf -m 100
   Word_Map : constant array (Hash_Value range 22 .. 114)
     of Program.Scanner_Destinations.Token_Kind :=
       (Else_Keyword,
        At_Keyword,
        Task_Keyword,
        Then_Keyword,
        Not_Keyword,
        Range_Keyword,
        Abs_Keyword,
        Renames_Keyword,
        Return_Keyword,
        End_Keyword,
        Terminate_Keyword,
        Case_Keyword,
        Xor_Keyword,
        Abstract_Keyword,
        Synchronized_Keyword,
        Reverse_Keyword,
        And_Keyword,
        Exception_Keyword,
        Constant_Keyword,
        Declare_Keyword,
        Access_Keyword,
        Record_Keyword,
        Accept_Keyword,
        Is_Keyword,
        In_Keyword,
        Type_Keyword,
        Entry_Keyword,
        Separate_Keyword,
        Or_Keyword,
        Requeue_Keyword,
        Do_Keyword,
        Select_Keyword,
        When_Keyword,
        Exit_Keyword,
        Array_Keyword,
        Raise_Keyword,
        Out_Keyword,
        Package_Keyword,
        Interface_Keyword,
        Pragma_Keyword,
        Delta_Keyword,
        Use_Keyword,
        Digits_Keyword,
        Abort_Keyword,
        Tagged_Keyword,
        Some_Keyword,
        Aliased_Keyword,
        Elsif_Keyword,
        Subtype_Keyword,
        Id,
        Generic_Keyword,
        For_Keyword,
        Function_Keyword,
        Id,
        Mod_Keyword,
        Null_Keyword,
        Delay_Keyword,
        Private_Keyword,
        Id, Id,
        All_Keyword,
        Procedure_Keyword,
        New_Keyword,
        While_Keyword,
        Id,
        With_Keyword,
        Protected_Keyword,
        Others_Keyword,
        Id,
        If_Keyword,
        Goto_Keyword,
        Of_Keyword,
        Until_Keyword,
        Body_Keyword,
        Overriding_Keyword,
        Id, Id, Id, Id, Id,
        Limited_Keyword,
        Id,
        Begin_Keyword,
        Loop_Keyword,
        Id, Id, Id, Id, Id, Id, Id, Id,
        Rem_Keyword);

   Word_Text : constant Wide_Wide_String :=
     "else"
     & "at"
     & "task"
     & "then"
     & "not"
     & "range"
     & "abs"
     & "renames"
     & "return"
     & "end"
     & "terminate"
     & "case"
     & "xor"
     & "abstract"
     & "synchronized"
     & "reverse"
     & "and"
     & "exception"
     & "constant"
     & "declare"
     & "access"
     & "record"
     & "accept"
     & "is"
     & "in"
     & "type"
     & "entry"
     & "separate"
     & "or"
     & "requeue"
     & "do"
     & "select"
     & "when"
     & "exit"
     & "array"
     & "raise"
     & "out"
     & "package"
     & "interface"
     & "pragma"
     & "delta"
     & "use"
     & "digits"
     & "abort"
     & "tagged"
     & "some"
     & "aliased"
     & "elsif"
     & "subtype"
     & "generic"
     & "for"
     & "function"
     & "mod"
     & "null"
     & "delay"
     & "private"
     & "all"
     & "procedure"
     & "new"
     & "while"
     & "with"
     & "protected"
     & "others"
     & "if"
     & "goto"
     & "of"
     & "until"
     & "body"
     & "overriding"
     & "limited"
     & "begin"
     & "loop"
     & "rem";

   Word_From : constant array (Hash_Value range 22 .. 114) of Natural :=
     (1,
      5,
      7,
      11,
      15,
      18,
      23,
      26,
      33,
      39,
      42,
      51,
      55,
      58,
      66,
      78,
      85,
      88,
      97,
      105,
      112,
      118,
      124,
      130,
      132,
      134,
      138,
      143,
      151,
      153,
      160,
      162,
      168,
      172,
      176,
      181,
      186,
      189,
      196,
      205,
      211,
      216,
      219,
      225,
      230,
      236,
      240,
      247,
      252,  --  Subtype_Keyword,
      0,
      259,  --  Generic_Keyword,
      266,  --  For_Keyword,
      269,  --  Function_Keyword,
      0,
      277,  --  Mod_Keyword,
      280,  --  Null_Keyword,
      284,  --  Delay_Keyword,
      289,  --  Private_Keyword,
      0, 0,
      296,  --  All_Keyword,
      299,  --  Procedure_Keyw
      308,  --  New_Keyword,
      311,  --  While_Keyword,
      0,
      316,  --  With_Keyword,
      320,  --  Protected_Keywo
      329,  --  Others_Keyword,
      0,
      335,  --  If_Keyword,
      337,  --  Goto_Keyword,
      341,  --  Of_Keyword,
      343,  --  Until_Keyword,
      348,  --  Body_Keyword,
      352,  --  Overriding_Keyword,
      0, 0, 0, 0, 0,
      362,  --  Limited_Keyword,
      0,
      369,  --  Begin_Keyword
      374,  --  Loop_Keyword,
      0, 0, 0, 0, 0, 0, 0, 0,
      378);  --  Rem_Keyword, Total length  381);

   -----------------------
   -- Character_Literal --
   -----------------------

   overriding procedure Character_Literal
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Value : Program.Scanner_Destinations.Token;
   begin
      Scanner.Set_Start_Condition (Program.Scanner_States.Allow_Char);
      Token := Character_Literal;
      Skip := False;
      Value := (Kind => Token, Span => Scanner.Get_Span);
      Self.Output.New_Token (Value);
      Self.Last_Token := Token;
   end Character_Literal;

   -------------
   -- Comment --
   -------------

   overriding procedure Comment
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Self, Scanner, Rule, Token);
   begin
      Skip := True;
   end Comment;

   ---------------
   -- Delimiter --
   ---------------

   overriding procedure Delimiter
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean)
   is
      Value : Program.Scanner_Destinations.Token;
   begin
      Scanner.Set_Start_Condition (Program.Scanner_States.Allow_Char);
      Token := Map (Rule);
      Skip := False;
      Value := (Kind => Token, Span => Scanner.Get_Span);
      Self.Output.New_Token (Value);
      Self.Last_Token := Token;
   end Delimiter;

   -----------
   -- Error --
   -----------

   overriding procedure Error
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Value : Program.Scanner_Destinations.Token;
   begin
      Token := Error;
      Skip := False;
      Value := (Kind => Token, Span => Scanner.Get_Span);
      Self.Output.New_Token (Value);
      Self.Last_Token := Token;
   end Error;

   ----------
   -- Hash --
   ----------

   function Hash (W : Wide_Wide_String) return Hash_Value is
      X : constant array (Wide_Wide_Character range 'a' .. 'y') of Positive :=
        (13,  51,  17, 11,   6,  52,  41,  38,  37, 115,   6,  33,  51,
         7,  39,  29,  29,   9,   6,   8,  48,  15,  37, 13,  29);

      function Y (Val : Wide_Wide_Character) return Positive;

      function Y (Val : Wide_Wide_Character) return Positive is
      begin
         if Val in X'Range then
            return X (Val);
         else
            return 115;
         end if;
      end Y;
      Length : constant Positive := W'Length;
      Result : Positive := Length;     --  2 .. 12
   begin
      if Length > 2 then
         Result := Result + Y (W (W'First + 2));  --  6 .. 115
      end if;

      Result := Result + Y (W (W'First));  --  6 .. 115

      Result := Result + Y (W (Length));  --  6 .. 115

      return Result;
   end Hash;

   ----------------
   -- Identifier --
   ----------------

   overriding procedure Identifier
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);

      Value : Program.Scanner_Destinations.Token;
      Span : constant Program.Source_Buffers.Span := Scanner.Get_Span;
      Text : constant Wide_Wide_String := Scanner.Get_Source.Text (Span);
      Match : constant Wide_Wide_String :=
        Ada.Wide_Wide_Characters.Handling.To_Lower (Text);
   begin
      Token := To_Token (Match);
      Skip := False;

      if Self.Last_Token = Apostrophe and Token /= Range_Keyword then
         Token := Id;
      end if;

      if Token = Id then
         Scanner.Set_Start_Condition (Program.Scanner_States.INITIAL);
      else
         Scanner.Set_Start_Condition (Program.Scanner_States.Allow_Char);
      end if;

      Value := (Kind => Token, Span => Scanner.Get_Span);
      Self.Output.New_Token (Value);
      Self.Last_Token := Token;
   end Identifier;

   --------------
   -- New_Line --
   --------------

   overriding procedure New_Line
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Scanner, Rule, Token);
   begin
      Skip := True;
      Self.Output.New_Line (Self.Line);
      Self.Line := Self.Line + 1;
   end New_Line;

   ---------------------
   -- Numeric_Literal --
   ---------------------

   overriding procedure Numeric_Literal
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Value : Program.Scanner_Destinations.Token;
   begin
      Scanner.Set_Start_Condition (Program.Scanner_States.Allow_Char);
      Token := Numeric_Literal;
      Skip := False;
      Value := (Kind => Token, Span => Scanner.Get_Span);
      Self.Output.New_Token (Value);
      Self.Last_Token := Token;
   end Numeric_Literal;

   ---------------------------------
   -- Obsolescent_Numeric_Literal --
   ---------------------------------

   overriding procedure Obsolescent_Numeric_Literal
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean) renames Numeric_Literal;

   --------------------------------
   -- Obsolescent_String_Literal --
   --------------------------------

   overriding procedure Obsolescent_String_Literal
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean) renames String_Literal;

   -----------
   -- Space --
   -----------

   overriding procedure Space
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Self, Scanner, Rule, Token);
   begin
      Skip := True;
   end Space;

   --------------------
   -- String_Literal --
   --------------------

   overriding procedure String_Literal
     (Self    : not null access Handler;
      Scanner : not null access Program.Scanners.Scanner'Class;
      Rule    : Program.Scanner_States.Rule_Index;
      Token   : out Program.Scanner_Destinations.Token_Kind;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Value : Program.Scanner_Destinations.Token;
   begin
      Scanner.Set_Start_Condition (Program.Scanner_States.Allow_Char);
      Token := String_Literal;
      Skip := False;
      Value := (Kind => Token, Span => Scanner.Get_Span);
      Self.Output.New_Token (Value);
      Self.Last_Token := Token;
   end String_Literal;

   --------------
   -- To_Token --
   --------------

   function To_Token
     (X : Wide_Wide_String)
      return Program.Scanner_Destinations.Token_Kind
   is
      H : Hash_Value;
   begin
      if X'Length in 2 .. 12 then
         H := Hash (X);

         if H in Word_From'Range and then
           Word_From (H) + X'Length - 1 <= Word_Text'Last and then
           Word_Text (Word_From (H) .. Word_From (H) + X'Length - 1) = X
         then
            return Word_Map (H);
         end if;
      end if;

      return Identifier;
   end To_Token;


end Program.Lexical_Handlers;
