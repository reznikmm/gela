------------------------------------------------------------------------------
--                        G E L A   G R A M M A R S                         --
--        Library for dealing with grammars for for Gela project,           --
--                        a portable Ada compiler                           --
--                        http://gela.ada-ru.org/                           --
--                     - - - - - - - - - - - - - - -                        --
--              Read copyright and license in gela.ads file                 --
------------------------------------------------------------------------------

with League.Characters;

with Gela.Lexical.Tokens; use Gela.Lexical.Tokens;

package body Gela.Lexical.Handler is

   function To_Token
     (X : League.Strings.Universal_String)
      return Gela.Lexical.Tokens.Token;
   --  Convert folded text to token

   subtype Hash_Value is Positive range 2 + 2 * 6 .. 12 + 3 * 115;

   function Hash (W : League.Strings.Universal_String) return Hash_Value;

   Map : constant array (Gela.Lexical.Types.Rule_Index range 1 .. 26) of
     Gela.Lexical.Tokens.Token :=
       (1 => Arrow_Token, 2 => Double_Dot_Token, 3 => Double_Star_Token,
        4 => Assignment_Token, 5 => Inequality_Token,
        6 => Greater_Or_Equal_Token, 7 => Less_Or_Equal_Token,
        8 => Left_Label_Token, 9 => Right_Label_Token, 10 => Box_Token,
        11 => Ampersand_Token, 12 => Apostrophe_Token,
        13 => Left_Parenthesis_Token, 14 => Right_Parenthesis_Token,
        15 => Star_Token, 16 => Plus_Token, 17 => Comma_Token,
        18 => Hyphen_Token, 19 => Dot_Token, 20 => Slash_Token,
        21 => Colon_Token, 22 => Semicolon_Token, 23 => Less_Token,
        24 => Equal_Token, 25 => Greater_Token, 26 => Vertical_Line_Token);

   Id : constant Gela.Lexical.Tokens.Token :=
     Gela.Lexical.Tokens.Identifier_Token;

   --  generated by gperf -m 100
   Word_Map : constant array (Hash_Value range 22 .. 114)
     of Gela.Lexical.Tokens.Token :=
       (Gela.Lexical.Tokens.Else_Token,
        Gela.Lexical.Tokens.At_Token,
        Gela.Lexical.Tokens.Task_Token,
        Gela.Lexical.Tokens.Then_Token,
        Gela.Lexical.Tokens.Not_Token,
        Gela.Lexical.Tokens.Range_Token,
        Gela.Lexical.Tokens.Abs_Token,
        Gela.Lexical.Tokens.Renames_Token,
        Gela.Lexical.Tokens.Return_Token,
        Gela.Lexical.Tokens.End_Token,
        Gela.Lexical.Tokens.Terminate_Token,
        Gela.Lexical.Tokens.Case_Token,
        Gela.Lexical.Tokens.Xor_Token,
        Gela.Lexical.Tokens.Abstract_Token,
        Gela.Lexical.Tokens.Synchronized_Token,
        Gela.Lexical.Tokens.Reverse_Token,
        Gela.Lexical.Tokens.And_Token,
        Gela.Lexical.Tokens.Exception_Token,
        Gela.Lexical.Tokens.Constant_Token,
        Gela.Lexical.Tokens.Declare_Token,
        Gela.Lexical.Tokens.Access_Token,
        Gela.Lexical.Tokens.Record_Token,
        Gela.Lexical.Tokens.Accept_Token,
        Gela.Lexical.Tokens.Is_Token,
        Gela.Lexical.Tokens.In_Token,
        Gela.Lexical.Tokens.Type_Token,
        Gela.Lexical.Tokens.Entry_Token,
        Gela.Lexical.Tokens.Separate_Token,
        Gela.Lexical.Tokens.Or_Token,
        Gela.Lexical.Tokens.Requeue_Token,
        Gela.Lexical.Tokens.Do_Token,
        Gela.Lexical.Tokens.Select_Token,
        Gela.Lexical.Tokens.When_Token,
        Gela.Lexical.Tokens.Exit_Token,
        Gela.Lexical.Tokens.Array_Token,
        Gela.Lexical.Tokens.Raise_Token,
        Gela.Lexical.Tokens.Out_Token,
        Gela.Lexical.Tokens.Package_Token,
        Gela.Lexical.Tokens.Interface_Token,
        Gela.Lexical.Tokens.Pragma_Token,
        Gela.Lexical.Tokens.Delta_Token,
        Gela.Lexical.Tokens.Use_Token,
        Gela.Lexical.Tokens.Digits_Token,
        Gela.Lexical.Tokens.Abort_Token,
        Gela.Lexical.Tokens.Tagged_Token,
        Gela.Lexical.Tokens.Some_Token,
        Gela.Lexical.Tokens.Aliased_Token,
        Gela.Lexical.Tokens.Elsif_Token,
        Gela.Lexical.Tokens.Subtype_Token,
        Id,
        Gela.Lexical.Tokens.Generic_Token,
        Gela.Lexical.Tokens.For_Token,
        Gela.Lexical.Tokens.Function_Token,
        Id,
        Gela.Lexical.Tokens.Mod_Token,
        Gela.Lexical.Tokens.Null_Token,
        Gela.Lexical.Tokens.Delay_Token,
        Gela.Lexical.Tokens.Private_Token,
        Id, Id,
        Gela.Lexical.Tokens.All_Token,
        Gela.Lexical.Tokens.Procedure_Token,
        Gela.Lexical.Tokens.New_Token,
        Gela.Lexical.Tokens.While_Token,
        Id,
        Gela.Lexical.Tokens.With_Token,
        Gela.Lexical.Tokens.Protected_Token,
        Gela.Lexical.Tokens.Others_Token,
        Id,
        Gela.Lexical.Tokens.If_Token,
        Gela.Lexical.Tokens.Goto_Token,
        Gela.Lexical.Tokens.Of_Token,
        Gela.Lexical.Tokens.Until_Token,
        Gela.Lexical.Tokens.Body_Token,
        Gela.Lexical.Tokens.Overriding_Token,
        Id, Id, Id, Id, Id,
        Gela.Lexical.Tokens.Limited_Token,
        Id,
        Gela.Lexical.Tokens.Begin_Token,
        Gela.Lexical.Tokens.Loop_Token,
        Id, Id, Id, Id, Id, Id, Id, Id,
        Gela.Lexical.Tokens.Rem_Token);

   type Universal_String_Array is array (Hash_Value range 22 .. 114)
     of League.Strings.Universal_String;
   type Universal_String_Array_Access is access all Universal_String_Array;

   Word_List : Universal_String_Array_Access;

   -----------------------
   -- Character_Literal --
   -----------------------

   overriding procedure Character_Literal
     (Self    : not null access Handler;
      Scanner : not null access Gela.Lexical.Scanners.Scanner'Class;
      Rule    : Gela.Lexical.Types.Rule_Index;
      Token   : out Gela.Lexical.Tokens.Token;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Token_Length : constant Positive := Scanner.Get_Token_Length;
   begin
      Scanner.Set_Start_Condition (Gela.Lexical.Types.Allow_Char);
      Token := Gela.Lexical.Tokens.Character_Literal_Token;
      Skip := False;

      Self.Fabric.New_Token
        (Token     => Token,
         Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Token_Length - 1,
         Separator => Self.Separator,
         Folded    => Scanner.Get_Text);

      Self.Last := Self.Last + Token_Length;
      Self.Separator := Self.Last;
   end Character_Literal;

   -------------
   -- Comment --
   -------------

   overriding procedure Comment
     (Self    : not null access Handler;
      Scanner : not null access Gela.Lexical.Scanners.Scanner'Class;
      Rule    : Gela.Lexical.Types.Rule_Index;
      Token   : out Gela.Lexical.Tokens.Token;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      pragma Unreferenced (Token);
      Token_Length : constant Positive := Scanner.Get_Token_Length;
   begin
      Skip := True;
      Self.Comment := Self.Last;
      Self.Last := Self.Last + Token_Length;
   end Comment;

   ---------------
   -- Delimiter --
   ---------------

   overriding procedure Delimiter
     (Self    : not null access Handler;
      Scanner : not null access Gela.Lexical.Scanners.Scanner'Class;
      Rule    : Gela.Lexical.Types.Rule_Index;
      Token   : out Gela.Lexical.Tokens.Token;
      Skip    : in out Boolean)
   is
      Token_Length : constant Positive := Scanner.Get_Token_Length;
   begin
      Scanner.Set_Start_Condition (Gela.Lexical.Types.Allow_Char);
      Token := Map (Rule);
      Skip := False;

      Self.Fabric.New_Token
        (Token     => Token,
         Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Token_Length - 1,
         Separator => Self.Separator,
         Folded    => League.Strings.Empty_Universal_String);

      Self.Last := Self.Last + Token_Length;
      Self.Separator := Self.Last;
   end Delimiter;

   -----------
   -- Error --
   -----------

   overriding procedure Error
     (Self    : not null access Handler;
      Scanner : not null access Gela.Lexical.Scanners.Scanner'Class;
      Rule    : Gela.Lexical.Types.Rule_Index;
      Token   : out Gela.Lexical.Tokens.Token;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      pragma Unreferenced (Token);
      Token_Length : constant Positive := Scanner.Get_Token_Length;
   begin
      Skip := True;
      Self.Last := Self.Last + Token_Length;
   end Error;

   ----------
   -- Hash --
   ----------

   function Hash (W : League.Strings.Universal_String) return Hash_Value is
      X : constant array (Wide_Wide_Character range 'a' .. 'y') of Positive :=
        (13,  51,  17, 11,   6,  52,  41,  38,  37, 115,   6,  33,  51,
         7,  39,  29,  29,   9,   6,   8,  48,  15,  37, 13,  29);

      function Y (Z : League.Characters.Universal_Character) return Positive;

      function Y (Z : League.Characters.Universal_Character) return Positive is
         Val : constant Wide_Wide_Character := Z.To_Wide_Wide_Character;
      begin
         if Val in X'Range then
            return X (Val);
         else
            return 115;
         end if;
      end Y;
      Length : constant Positive := W.Length;
      Result : Positive := Length;     --  2 .. 12
   begin
      if Length > 2 then
         Result := Result + Y (W.Element (3));  --  6 .. 115
      end if;

      Result := Result + Y (W.Element (1));  --  6 .. 115

      Result := Result + Y (W.Element (Length));  --  6 .. 115

      return Result;
   end Hash;

   ----------------
   -- Identifier --
   ----------------

   overriding procedure Identifier
     (Self    : not null access Handler;
      Scanner : not null access Gela.Lexical.Scanners.Scanner'Class;
      Rule    : Gela.Lexical.Types.Rule_Index;
      Token   : out Gela.Lexical.Tokens.Token;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);

      Token_Length : constant Positive := Scanner.Get_Token_Length;
      Text : constant League.Strings.Universal_String :=
        Scanner.Get_Text.To_Lowercase;
   begin
      Token := To_Token (Text);
      Skip := False;

      if Token = Id then
         Scanner.Set_Start_Condition (Gela.Lexical.Types.INITIAL);
      else
         Scanner.Set_Start_Condition (Gela.Lexical.Types.Allow_Char);
      end if;

      Self.Fabric.New_Token
        (Token     => Token,
         Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Token_Length - 1,
         Separator => Self.Separator,
         Folded    => Text);

      Self.Last := Self.Last + Token_Length;
      Self.Separator := Self.Last;
   end Identifier;

   ----------------
   -- Initialize --
   ----------------

   procedure Initialize is
      function "+"
        (Left : Wide_Wide_String)
         return League.Strings.Universal_String renames
        League.Strings.To_Universal_String;

      Nil : constant League.Strings.Universal_String :=
        League.Strings.Empty_Universal_String;

   begin
      Word_List := new Universal_String_Array'
        (+"else",
         +"at",
         +"task",
         +"then",
         +"not",
         +"range",
         +"abs",
         +"renames",
         +"return",
         +"end",
         +"terminate",
         +"case",
         +"xor",
         +"abstract",
         +"synchronized",
         +"reverse",
         +"and",
         +"exception",
         +"constant",
         +"declare",
         +"access",
         +"record",
         +"accept",
         +"is",
         +"in",
         +"type",
         +"entry",
         +"separate",
         +"or",
         +"requeue",
         +"do",
         +"select",
         +"when",
         +"exit",
         +"array",
         +"raise",
         +"out",
         +"package",
         +"interface",
         +"pragma",
         +"delta",
         +"use",
         +"digits",
         +"abort",
         +"tagged",
         +"some",
         +"aliased",
         +"elsif",
         +"subtype",
         Nil,
         +"generic",
         +"for",
         +"function",
         Nil,
         +"mod",
         +"null",
         +"delay",
         +"private",
         Nil, Nil,
         +"all",
         +"procedure",
         +"new",
         +"while",
         Nil,
         +"with",
         +"protected",
         +"others",
         Nil,
         +"if",
         +"goto",
         +"of",
         +"until",
         +"body",
         +"overriding",
         Nil, Nil, Nil, Nil, Nil,
         +"limited",
         Nil,
         +"begin",
         +"loop",
         Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil,
         +"rem");
   end Initialize;

   --------------
   -- New_Line --
   --------------

   overriding procedure New_Line
     (Self    : not null access Handler;
      Scanner : not null access Gela.Lexical.Scanners.Scanner'Class;
      Rule    : Gela.Lexical.Types.Rule_Index;
      Token   : out Gela.Lexical.Tokens.Token;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      pragma Unreferenced (Token);

      Token_Length : constant Positive := Scanner.Get_Token_Length;
      Comment      : Text_Index;
   begin
      Skip := True;

      if Self.Comment > Self.Line_First then
         Comment := Self.Comment;
      else
         Comment := Self.Last + 1;
      end if;

      Self.Fabric.New_Line
        (First   => Self.Line_First,
         Last    => Self.Last,
         Comment => Comment);

      Self.Last := Self.Last + Token_Length;
      Self.Line := Self.Line + 1;
      Self.Line_First := Self.Last;
   end New_Line;

   ---------------------
   -- Numeric_Literal --
   ---------------------

   overriding procedure Numeric_Literal
     (Self    : not null access Handler;
      Scanner : not null access Gela.Lexical.Scanners.Scanner'Class;
      Rule    : Gela.Lexical.Types.Rule_Index;
      Token   : out Gela.Lexical.Tokens.Token;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Token_Length : constant Positive := Scanner.Get_Token_Length;
   begin
      Scanner.Set_Start_Condition (Gela.Lexical.Types.Allow_Char);
      Token := Gela.Lexical.Tokens.Numeric_Literal_Token;
      Skip := False;

      Self.Fabric.New_Token
        (Token     => Token,
         Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Token_Length - 1,
         Separator => Self.Separator,
         Folded    => League.Strings.Empty_Universal_String);

      Self.Last := Self.Last + Token_Length;
      Self.Separator := Self.Last;
   end Numeric_Literal;

   ----------------
   -- Set_Fabric --
   ----------------

   procedure Set_Fabric
     (Self   : in out Handler;
      Fabric : not null Gela.Lexical.Fabrics.Fabric_Access) is
   begin
      Self.Fabric := Fabric;
   end Set_Fabric;

   -----------
   -- Space --
   -----------

   overriding procedure Space
     (Self    : not null access Handler;
      Scanner : not null access Gela.Lexical.Scanners.Scanner'Class;
      Rule    : Gela.Lexical.Types.Rule_Index;
      Token   : out Gela.Lexical.Tokens.Token;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      pragma Unreferenced (Token);
      Token_Length : constant Positive := Scanner.Get_Token_Length;
   begin
      Skip := True;
      Self.Last := Self.Last + Token_Length;
   end Space;

   --------------------
   -- String_Literal --
   --------------------

   overriding procedure String_Literal
     (Self    : not null access Handler;
      Scanner : not null access Gela.Lexical.Scanners.Scanner'Class;
      Rule    : Gela.Lexical.Types.Rule_Index;
      Token   : out Gela.Lexical.Tokens.Token;
      Skip    : in out Boolean)
   is
      pragma Unreferenced (Rule);
      Token_Length : constant Positive := Scanner.Get_Token_Length;
   begin
      Scanner.Set_Start_Condition (Gela.Lexical.Types.Allow_Char);
      Token := Gela.Lexical.Tokens.String_Literal_Token;
      Skip := False;

      Self.Fabric.New_Token
        (Token     => Token,
         Line      => Self.Line,
         First     => Self.Last,
         Last      => Self.Last + Token_Length - 1,
         Separator => Self.Separator,
         Folded    => Scanner.Get_Text);

      Self.Last := Self.Last + Token_Length;
      Self.Separator := Self.Last;
   end String_Literal;

   --------------
   -- To_Token --
   --------------

   function To_Token
     (X : League.Strings.Universal_String)
      return Gela.Lexical.Tokens.Token
   is
      use type League.Strings.Universal_String;
      H : Hash_Value;
   begin
      if X.Length in 2 .. 12 then
         H := Hash (X);

         if H in Word_List'Range and then Word_List (H) = X then
            return Word_Map (H);
         else
            return Gela.Lexical.Tokens.Identifier_Token;
         end if;
      else
         return Gela.Lexical.Tokens.Identifier_Token;
      end if;
   end To_Token;

   -----------------------
   -- Unfolded_To_Token --
   -----------------------

   function Unfolded_To_Token
     (X : League.Strings.Universal_String)
      return Gela.Lexical.Tokens.Token
   is
      Text : constant League.Strings.Universal_String := X.To_Lowercase;
   begin
      return To_Token (Text);
   end Unfolded_To_Token;

end Gela.Lexical.Handler;
