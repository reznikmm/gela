!standard 13.43                                    08-02-15  SI99-0022-1/07
!standard 13.44
!standard 13.45
!class Binding Interpretation 06-11-17
!status ARG Approved  6-0-3  08-02-08
!status work item 06-10-10
!status received 06-10-10
!priority High
!difficulty Medium
!qualifier Omission
!subject Add Boolean queries to ease use of Trait_Kinds

!summary

Add a collection of Boolean queries to provide an alternative to the Trait_Kinds and
associated Trait_Kind query. Make Trait_Kinds and Trait_Kind obsolescent.

!question

Trait_Kinds require defining all possible combinations of traits. This
complicates both the definition and use of traits, because answering a simple
question like "Does this element include the keyword limited?" can require
checking for a number of traits. This is made worse with Ada 2005. Should there
be an alternative method of determining the presence/absence of syntax
constructs? (Yes.)

Also, the Amendment (Ada 2005) defines new types of With clauses; it must
be possible to determine what type of with clause is present by extending
traits or its replacement.

!recommendation

The presence/absence of certain syntactic constructs in a declaration
or definition in ASIS 95 could be determined by examining trait_kinds.
Several trait_kinds may map to a single syntactic entity (for example,
the trait kinds An_Abstract_Trait, An_Abstract_Limited_Trait,
An_Abstract_Private_Trait, and An_Abstract_Limited_Private_Trait all
indicate the presence of "abstract" in the declaration.)

With the changes from Ada 2005, trait_kinds are difficult to extend to
consistently accommodate the new syntactic constructs. As such, they
are replaced by Boolean queries to allow for determination of the
presence/absence of the syntactic constructs in a declaration or
definition that are accessible via traits.
Trait_kinds and the associated trait_kind query become obsolescent.

The following queries are added:

function Has_Abstract ( Element : in Asis.Element ) return Boolean;
function Has_Aliased (Element : in Asis.Element ) return Boolean;
function Has_Limited ( Element : in Asis.Element ) return Boolean;
function Has_Private ( Element : in Asis.Element ) return Boolean;
function Has_Protected (Element : in Asis.Element ) return Boolean;
function Has_Reverse (Element : in Asis.Element ) return Boolean;
function Has_Synchronized (Element : in Asis.Element ) return Boolean;
function Has_Tagged (Element : in Asis.Element ) return Boolean;
function Has_Task (Element : in Asis.Element ) return Boolean;

The four functions Has_Task, Has_Protected, Has_Synchronized and Has_Tagged 
are included for consistency. They are not necessary to replace Trait_Kinds.

!wording

- In section 3.9.1, 
  replace "Trait_Kinds'An_Access_Definition_Trait"
  with "Mode_Kinds'An_In_Mode"

  replace ( Who : access Person )
  with    ( Who : in Person )

  Delete all 4 lines that contain "-> Trait_Kinds"

In 3.9.4,
- Delete all 10 occurrences of "-> Trait_Kinds"

In 3.9.9, 3.9.10 and 3.9.11, 
- delete all 11 occurrences of "-> Trait_Kinds"

Make 3.9.5 obsolescent
- Replace "3.9.5 type Trait_Kinds"
  with "3.9.5 type Trait_Kinds (Obsolescent) - see clause X"

Make 13.10 obsolescent
- Replace "13.10 function Trait_Kind"
  with "13.10 function Trait_Kind (Obsolescent) - see clause X"


Add the following new clauses to section 13:

13.xx function Has_Abstract

function Has_Abstract ( Element : in Asis.Element ) return Boolean;

Element specifies the element to query.

Returns True if the reserved word *abstract* appears in Element, and
False otherwise.

Returns False for any unexpected element, including a Nil_Element.

Element expects an element that has one of the following Declaration_Kinds:
  A_Formal_Procedure_Declaration
  A_Formal_Function_Declaration
  A_Function_Declaration
  A_Private_Type_Declaration
  A_Private_Extension_Declaration
  A_Procedure_Declaration
  A_Type_Declaration

or an element that has one of the following Definition_Kinds:
  A_Private_Extension_Definition
  A_Private_Type_Definition
  A_Tagged_Private_Type_Definition
  A_Type_Definition

or an element that has one of the following Formal_Type_Kinds:
  A_Formal_Private_Type_Definition
  A_Formal_Tagged_Private_Type_Definition
  A_Formal_Derived_Type_Definition


13.xx function Has_Aliased

function Has_Aliased ( Element : in Asis.Element ) return Boolean;

Element specifies the Element to query.

Returns True if the reserved word *aliased* appears in Element, and
False otherwise.

Returns False for any unexpected element, including a Nil_Element.

Element expects an element that has one of the following Declaration_Kinds:
  A_Constant_Declaration
  A_Deferred_Constant_Declaration
  A_Return_Object_Specification  
  A_Variable_Declaration

or an element that has one of the following Definition_Kinds:
  A_Component_Definition


13.xx function Has_Limited


function Has_Limited ( Element : in Asis.Element ) return Boolean;

Element specifies the Element to query.

Returns True if the reserved word *limited* appears in Element, and
False otherwise.

Returns False for any unexpected element, including a Nil_Element.

Element expects an element that has one of the following Clause_Kinds:
  A_With_Clause

or an element that has one of the following Declaration_Kinds:
  A_Type_Declaration
  A_Private_Type_Declaration
  A_Private_Extension_Declaration

or an element that has one of the following Definition_Kinds:
  A_Type_Definition
  A_Private_Type_Definition
  A_Tagged_Private_Type_Definition
  A_Private_Extension_Definition
  An_Interface_Type_Definition

or an element that has one of the following Formal_Type_Kinds:
  A_Formal_Private_Type_Definition
  A_Formal_Tagged_Private_Type_Definition
  A_Formal_Derived_Type_Definition


13.xx function Has_Private

function Has_Private ( Element : in Asis.Element ) return Boolean;

Element specifies the element to query.

Returns True if the reserved word *private* appears in Element, and
False otherwise.

Returns False for any unexpected element, including a Nil_Element.

Element expects an element that has one of the following Declaration_Kinds:
  A_Type_Declaration
  A_Private_Type_Declaration

or an element that has one of the following Definition_Kinds:
  A_Private_Extension_Definition
  A_Private_Type_Definition
  A_Tagged_Private_Type_Definition
  A_Type_Definition

or an element that has one of the following Formal_Type_Kinds:
  A_Formal_Private_Type_Definition
  A_Formal_Tagged_Private_Type_Definition

or an element that has one of the following Clause_Kinds:
  A_With_Clause


13.xx function Has_Protected

function Has_Protected( Element : in Asis.Element ) return Boolean;

Element specifies the Element to query.

Returns True if the reserved word *protected* appears in Element, and
False otherwise.

Returns False for any unexpected element, including a Nil_Element.

Element expects an element that has one of the following Definition_Kinds:
  An_Interface_Type_Definition
  A_Protected_Definition

or an element that has one of the following Declaration_Kinds
  A_Protected_Body_Declaration         
  A_Protected_Type_Declaration
  A_Single_Protected_Declaration


13.xx function Has_Reverse

function Has_Reverse ( Element : in Asis.Element ) return Boolean;

Element specifies the Element to query.

Returns True if the reserved word *reverse* appears in Element, and
False otherwise.

Returns False for any unexpected element, including a Nil_Element.

Element expects an element that has one of the following Declaration_Kinds:
  A_Loop_Parameter_Specification


13.xx function Has_Synchronized

function Has_Synchronized ( Element : in Asis.Element ) return Boolean;

Element specifies the Element to query.

Returns True if the reserved word *synchronized* appears in Element, and
False otherwise.

Returns False for any unexpected element, including a Nil_Element.
 
Element expects an element that has one of the following Definition_Kinds:
  An_Interface_Type_Definition
  A_Private_Extension_Definition


13.xx function Has_Tagged

function Has_Tagged( Element : in Asis.Element ) return Boolean;

Element specifies the Element to query.

Returns True if the reserved word *tagged* appears in Element, and
False otherwise.

Returns False for any unexpected element, including a Nil_Element.

Element expects an element that has one of the following Definition_Kinds:
  A_Tagged_Incomplete_Type_Definition
  A_Tagged_Private_Type_Definition
  A_Tagged_Record_Type_Definition

or an element that has one of the following Type_Kinds:
  A_Tagged_Record_Type_Definition

or an element that has one of the following Formal_Type_Kinds:
  A_Formal_Tagged_Private_Type_Definition


13.xx function Has_Task

function Has_Task( Element : in Asis.Element ) return Boolean;

Element specifies the Element to query.

Returns True if the reserved word *task* appears in Element, and
False otherwise.

Returns False for any unexpected element, including a Nil_Element.

Element expects an element that has one of the following Definition_Kinds:
  An_Interface_Type_Definition
  A_Task_Definition

or an element that has one of the following Declaration_Kinds
  A_Task_Type_Declaration
  A_Single_task_Declaration
  A_Task_Body_Declaration        


!discussion

Some existing traits are obsolete (specifically, the "access" trait); it would be
too messy to handle all of the possible forms and locations of anonymous access
types with traits. (It especially doesn't make sense for anonymous access-to-subprogram
types.) It doesn't make sense to make individual enumeration literals obsolete.

Testing for a single entity is difficult and error prone. For instance, checking for
the presence of limited for a type definition requires checking if any of the traits
A_Limited_Trait, A_Limited_Private_Trait, An_Abstract_Limited_Trait, or
An_Abstract_Limited_Private_Trait are present. If any of these are omitted, the program
will get incorrrect answers.

Ada 2005 would require addiing traits for Synchronized and null exclusions, which would
add a number of new combinations. It's clear that the trait mechanism does not scale well.

Therefore, we're making the trait mechanism obsolescent, and will not add any
Ada 2005 features to its support.

Another advantage of the query functions is that the list of expected elements can be
tailored for the item in question. That allows additional checking by preventing
nonsense queries like asking if A_Deferred_Constant has the "Abstract" trait.

The queries need to support determining if "limited" and "private" are present on
with_clauses, as the Amendment adds limited_with_clauses and private_with_clauses.

As this set of queries provides a uniform approach for querying about the presence of
certain reserved words, extending the set to cover a larger set of reserved words was
investigated. Similar queries are added for Task, Protected, Synchronized, and Tagged,
even though alternate mechanisms exist to determine their presence/absence.
The reserved words *Constant* and *All* were rejected as adding too much confusion 
because they could appear in subelements of the element, and whether or not that 
should be taken into account is unclear. *Until* is covered by the
A_Delay_Until_Statement Statement_Kind (there is no A_Delay_Statement Statement_Kind, 
only A_Delay_Until_Statement and A_Delay_Relative_Statement).

!appendix

Subject: Summary of the proposals for updating the ASIS Standard for Ada 2005
From: Sergey I. Rybin
Date: Mon, 13 Feb 2006 13:55:06 +0300

Formally the ASIS revision process is supposed to be started only after
finishing all the technical work with the new revision of the Ada Standard,
but I think we can start some preliminary technical work with new ASIS
definition already now (all the changes in Ada definition are stable
enough to start the ASIS revision).

At AdaCore we have developed a draft version of the new ASIS specification
and most of the proposed changes are already implemented in the latest
version of GNAT/ASIS technology. The attached file contains the summary
of the changes in the ASIS Standard we have made to adopt the new Ada
features. The interesting thing I've realized when working on
our draft of the new ASIS specification is that if we would like
to keep the upward compatibility as much as possible and if we
would like to keep changes as small as possible,
the new Ada definition gives us very limited freedom in making changes
in the ASIS spec. It does not mean that we think that our proposals
are the only possible solution for ASIS 2005, but it gives us some
hope that we can do ASIS revision for Ada 2005 fast enough.

There is quite a natural mapping of the proposed changes in the ASIS
specification onto the existing set of Ada Issues used for Ada revision,
and the attached file is structured and ordered by AIs. The only
exception is the new values in the ASIS Element Classification needed
to represent the new Ada 2005 predefined attributes and pragmas (of course,
this could be also mapped onto AIs, but I do not think that it would make
sense, because this is the easiest and completely straightforward part
of the ASIS revision).

My main goal of sending this ASIS 2005 Draft summary is to start
the ASIS 2005 discussion. The document itself would hardly be a convenient
background for this discussion - we will have at least split it on
changes related to different language issues, we will also have to
find a way for documenting the revision discussion, probably we
may need a separate mailing list for it. But let's get started!

Sergey Rybin


.....

---------------------------------
-- AI-217 Limited with clauses --
-- AI-262 Private with clauses --
---------------------------------
RM-06 10.1.2

* Add A_With_Clause to the list of expected kinds of Asis.Elements.Trait_Kind

****************************************************************

!topic SI99-0022-1 corrections
!reference Ada 2005 RM 7.3(2)
!from Maxim Reznik 07-12-31
!keywords abstract private type
!discussion

Please consider follow changes to ASIS SI99-0022-1.

For function

  function Has_Abstract (Element : in Asis.Element) return Boolean;

Follow Definition_Kinds should be removed:
--    A_Private_Type_Definition
--    An_Interface_Type_Definition
--    A_Formal_Private_Type_Definition
because they could not have keyword abstract according syntax rules:

private_type_declaration ::=
  type defining_identifier [discriminant_part] is [[abstract] tagged]
[limited] private;

Here 'abstract' goes with tagged only, but it has separate
A_Tagged_Private_Type_Definition kind.

formal_private_type_definition ::= [[abstract] tagged] [limited] private

Here 'abstract' goes with tagged only, but it has separate
A_Formal_Tagged_Private_Type_Definition kind.

interface_type_definition ::=
   [limited | task | protected | synchronized] interface [and interface_list]

All interface types are abstract, but none has keyword abstract in the syntax.

Follow Definition_Kinds should be added:
--    A_Tagged_Record_Type_Definition
--    A_Derived_Type_Definition
--    A_Derived_Record_Extension_Definition

record_type_definition ::= [[abstract] tagged] [limited] record_definition

derived_type_definition ::=
   [abstract] [limited] new parent_subtype_indication [[and
interface_list] record_extension_part]


For function

  function Has_Limited (Element : in Asis.Element) return Boolean;

Follow Definition_Kinds should be added:
--    A_Tagged_Record_Type_Definition
--    A_Record_Type_Definition
--    A_Derived_Type_Definition
--    A_Derived_Record_Extension_Definition
---   A_Formal_Interface_Type_Definition

For function
  function Has_Private (Element : in Asis.Element) return Boolean;

Follow Definition_Kind should be added:
--    A_Formal_Derived_Type_Definition

For function
  function Has_Synchronized (Element : in Asis.Element) return Boolean;

Follow Definition_Kind should be added:
--    A_Formal_Derived_Type_Definition

****************************************************************


