Token token;

Compilation ::= compilation_library_item;

access_definition ::=
  anonymous_access_to_object_definition |
  anonymous_access_to_function_definition |
  anonymous_access_to_procedure_definition;

anonymous_access_to_object_definition ::=
  token <not_token>
  token <access_token>
  token <constant_token>
  subtype_mark <Anonymous_Access_To_Object_Subtype_Mark>;

anonymous_access_to_procedure_definition ::=
  token <not_token>
  token <access_token>
  token <protected_token>
  token <procedure_token>
  {parameter_specification} <Access_To_Subprogram_Parameter_Profile>;

anonymous_access_to_function_definition ::=
  token <not_token>
  token <access_token>
  token <protected_token>
  token <function_token>
  {parameter_specification} <Access_To_Subprogram_Parameter_Profile>
  token <return_token>
  token <return_not_token>
  subtype_mark_or_access_definition <Access_To_Function_Result_Subtype>;

access_to_object_definition ::=
  token <not_token>
  token <access_token>
  token <constant_token>
  subtype_indication <Access_To_Object_Definition>
;

access_to_procedure_definition ::=
  token <not_token>
  token <access_token>
  token <protected_token>
  token <procedure_token>
  {parameter_specification} <Access_To_Subprogram_Parameter_Profile>;

access_to_function_definition ::=
  token <not_token>
  token <access_token>
  token <protected_token>
  token <function_token>
  {parameter_specification} <Access_To_Subprogram_Parameter_Profile>
  token <return_token>
  token <return_not_token>
  subtype_mark_or_access_definition <Access_To_Function_Result_Subtype>;

access_type_definition ::=
  access_to_object_definition |
  access_to_function_definition |
  access_to_procedure_definition;

allocator ::=
  token <new_token> name <Subtype_Or_Expression> name <Subpool_Name>;

association ::=
  {discrete_choice} <Array_Component_Choices>
  token             <arrow_token>
  expression_or_box <Component_Expression>;

aspect_clause ::=
  attribute_definition_clause |
  pragma_node;

aspect_specification ::=
   subtype_mark <Aspect_Mark>
   token <arrow_token>
   expression   <Aspect_Definition>
;

attribute_definition_clause ::=
  token <for_token>
  attribute_reference <Representation_Clause_Name>
  token <use_token>
  expression <Representation_Clause_Expression>
  token <semicolon_token>
;

attribute_reference ::=
  prefix
  token <apostrophe_token>
  identifier <Attribute_Designator_Identifier>
  token <designator_token>
  expression <Attribute_Designator_Expressions>
;

basic_declarative_item ::=
  basic_declaration |
  aspect_clause |
  use_clause;

basic_declaration ::=
  full_type_declaration |
  subtype_declaration |
  object_declaration |
  package_declaration |
  exception_renaming_declaration |
  exception_declaration;

box ::= token <box_token>;

compilation_library_item ::=
  {context_item} <Context_Clause_Elements>
  library_item   <Unit_Declaration>
  {pragma_node}  <Compilation_Pragmas>
;

context_item ::= with_clause | use_clause | pragma_node;

library_item ::= package_declaration;

component_declaration ::=
  {defining_identifier} <Names>
  token <colon_token>
  component_definition <Object_Declaration_Subtype>
  token <assignment_token>
  expression <Initialization_Expression>
  {aspect_specification} <Aspect_Specifications>
  token <semicolon_token>
;

component_item ::=
  component_declaration |
  aspect_clause |
  variant_part |
  null_component;

constrained_array_definition ::=
    token <array_token>
    token <left_token>
    {discrete_subtype_definition} <Discrete_Subtype_Definitions>
    token <right_token>
    token <of_token>
    component_definition <Array_Component_Definition>
;

constraint ::= scalar_constraint;

delta_constraint ::=
  token            <delta_token>
  expression       <Delta_Expression>
  range_constraint <Real_Range_Constraint>;

derived_type_definition ::=
  token <abstract_token>
  token <limited_token>
  token <new_token>
  subtype_indication <Parent_Subtype_Indication>
;

derived_record_definition ::=
  token <abstract_token>
  token <limited_token>
  token <new_token>
  subtype_indication <Parent_Subtype_Indication>
  {subtype_mark}     <Progenitor_List>
  token <with_token>
  alt_record_definition  <Record_Definition>
;

digits_constraint ::=
  token            <digits_token>
  expression       <Digits_Expression>
  range_constraint <Real_Range_Constraint>;

direct_name ::=
  identifier |
  operator_symbol;

discrete_choice ::= expression | discrete_range | others_choice;

discrete_range ::= discrete_subtype_indication_dr | range_dr;

discrete_subtype_definition ::=
   discrete_subtype_indication |
   discrete_range_attribute_reference |
   discrete_simple_expression_range;

discrete_subtype_indication ::=
    subtype_mark <Subtype_Mark>
    range_constraint <Subtype_Constraint>;

discrete_range_attribute_reference ::=
    attribute_reference <Range_Attribute>;

discrete_simple_expression_range ::=
  simple_expression <Lower_Bound>
  token <double_dot_token>
  simple_expression <Upper_Bound>
;


range_dr ::= range_attribute_reference_dr | simple_expression_range_dr;

discrete_subtype_indication_dr ::=
    subtype_mark <Subtype_Mark>
    range_constraint <Subtype_Constraint>;

discriminant_part ::=
  unknown_discriminant_part;

range_attribute_reference_dr ::=
    attribute_reference <Range_Attribute>;

simple_expression_range_dr ::=
  simple_expression <Lower_Bound>
  token <double_dot_token>
  simple_expression <Upper_Bound>
;

else_expression_path ::=
    token <else_token>
    expression <Dependent_Expression>
;

elsif_expression_path ::=
    token <elsif_token>
    expression <Condition_Expression>
    token <then_token>
    expression <Dependent_Expression>
;

enumeration_literal ::= token <enumeration_literal>;

exception_declaration ::=
  {defining_identifier}  <Names>
  token                  <colon_token>
  token                  <exception_token>
  {aspect_specification} <Aspect_Specifications>
  token                  <semicolon_token>
;

exception_renaming_declaration ::=
  {defining_identifier}  <Names>
  token                  <colon_token>
  token                  <exception_token>
  token                  <renames_token>
  name <Renamed_Entity>
  {aspect_specification} <Aspect_Specifications>
  token                  <semicolon_token>
;

explicit_dereference ::= name <Prefix> token <dot_token> token <all_token>;

expression ::= membership_test | simple_expression;

expression_or_box ::= expression | box;

extension_aggregate ::=
  token         <left_token>
  expression    <Extension_Aggregate_Expression>
  token         <with_token>
  {association} <Record_Component_Associations>
  token         <right_token>;

floating_point_definition ::=
  token      <digits_token>
  expression <Digits_Expression>
  simple_expression_range <Real_Range_Constraint>
;

function_call ::= prefix record_aggregate <Function_Call_Parameters>;

full_type_declaration ::=
  token         <type_token>
  defining_identifier <Names>
  discriminant_part <Discriminant_Part>
  token         <is_token>
  type_definition <Type_Declaration_View>
  {aspect_specification} <Aspect_Specifications>
  token <semicolon_token>
;


identifier ::= token <identifier>;

if_expression_path ::=
    token <if_token>
    expression <Condition_Expression>
    token <then_token>
    expression <Dependent_Expression>
;

if_else_expression_path ::=
  if_expression_path | elsif_expression_path | else_expression_path;

if_expression ::= {if_else_expression_path} <Expression_Paths>;

interface_type_definition ::=
    token <kind_token>
    token <interface_token>
    {subtype_mark} <Progenitor_List>
;

ordinary_fixed_point_definition ::=
  token                   <delta_token>
  expression              <Delta_Expression>
  simple_expression_range <Real_Range_Constraint>
;

decimal_fixed_point_definition ::=
  token                   <delta_token>
  expression              <Delta_Expression>
  token                   <digits_token>
  expression              <Digits_Expression>
  simple_expression_range <Real_Range_Constraint>
;

case_expression ::=
  token <case_token>
  expression <Case_Expression>
  token <is_token>
  {case_expression_path} <Case_Expression_Paths>;

case_expression_path ::=
    token <when_token>
    {discrete_choice} <Case_Path_Alternative_Choices>
    token <arrow_token>
    expression <Dependent_Expression>
;

component_definition ::=
  token <aliased_token>
  subtype_indication_or_access_definition <Component_Subtype_Indication>
;

defining_character_literal ::= token <character_literal>;

defining_enumeration_literal ::= token <identifier>;

defining_enumeration_name ::=
  defining_enumeration_literal | defining_character_literal;

defining_identifier ::= token <identifier>;

defining_program_unit_name ::=
  defining_identifier | defining_expanded_unit_name;

defining_expanded_unit_name ::=
  program_unit_name <Defining_Prefix>
  token <dot_token>
  defining_identifier <Defining_Selector>
;

enumeration_literal_specification ::= defining_enumeration_name <Names>;

enumeration_type_definition ::=
  token         <left_token>
  {enumeration_literal_specification} <Enumeration_Literal_Declarations>
  token         <right_token>
;

quantified_expression ::=
  token <for_token>
  token <quantifier_token>
  iterator_specification
  token <arrow_token>
  expression <predicate>
;

iterator_specification ::=
  generalized_iterator_specification |
  element_iterator_specification |
  loop_parameter_specification
;

generalized_iterator_specification ::=
   defining_identifier <Names>
   token <in_token>
   token <reverse_token>
   name <Iteration_Scheme_Name>;

element_iterator_specification ::=
   defining_identifier <Names>
   token <colon_token>
   subtype_indication
   token <of_token>
   token <reverse_token>
   name <Iteration_Scheme_Name>;

character_literal ::= token <character_literal>;

loop_parameter_specification ::=
  defining_identifier         <Names>
  token                       <in_token>
  token                       <reverse_token>
  discrete_subtype_definition <Specification_Subtype_Definition>
;


membership_test ::=
  simple_expression <Membership_Test_Expression>
  token <not_token>
  token <in_token>
  {membership_choice} <Membership_Test_Choices>
;

membership_choice ::= simple_expression | range_constraint;

modular_type_definition ::=
  token <mod_token>
  expression <Mod_Static_Expression>;

name ::= direct_name |
  explicit_dereference |
  selected_component |
  attribute_reference |
  function_call |
  character_literal;

null_component ::= token <null_token> token <semicolon_token>;

null_literal ::= token <null_literal>;

null_record_definition ::=
  token <null_token>
  token <record_token>;

numeric_literal ::= token <numeric_literal>;

object_declaration ::=
  {defining_identifier} <Names>
  token <colon_token>
  token <aliased_token>
  token <constant_token>
  object_definition <Object_Declaration_Subtype>
  token <assignment_token>
  expression <Initialization_Expression>
  {aspect_specification} <Aspect_Specifications>
  token <semicolon_token>
;

object_definition ::=
  subtype_indication |
  access_definition |
  unconstrained_array_definition |
  constrained_array_definition;

operator_symbol ::= token <operator_symbol>;

others_choice ::= token <others_token>;

package_declaration ::=
  token <package_token>
  defining_program_unit_name <Names>
  {aspect_specification} <Aspect_Specifications>
  token <is_token>
  {basic_declarative_item} <Visible_Part_Declarative_Items>
  token <private_token>
  {basic_declarative_item} <Private_Part_Declarative_Items>
  token <end_token>
  program_unit_name <end_name>
  token <semicolon_token>
;

parameter_specification ::=
  {defining_identifier}             <Names>
  token <colon_token> token <aliased_token> token <mode_token>
  token <not_token>
  subtype_mark_or_access_definition <Object_Declaration_Subtype>
  token <assignment_token>
  expression                        <Initialization_Expression>
;

pragma_node ::=
  token         <pragma_token>
  identifier    <Formal_Parameter>
  token         <left_token>
  {pragma_argument_association} <Pragma_Argument_Associations>
  token         <right_token>
  token <semicolon_token>
;

pragma_argument_association ::=
    identifier <Formal_Parameter>
    token      <arrow_token>
    expression <Actual_Parameter>
;

prefix ::= name;

program_unit_name ::= identifier | selected_identifier;

qualified_expression ::=
  subtype_mark <Converted_Or_Qualified_Subtype_Mark>
  token <apostrophe_token>
  expression <Converted_Or_Qualified_Expression>;

range_constraint ::= range_attribute_reference | simple_expression_range;

range_attribute_reference ::=
  attribute_reference <Range_Attribute>;

record_aggregate ::=
  token         <left_token>
  {association} <Record_Component_Associations>
  token         <right_token>;

record_definition ::=
  token <record_token>
    {component_item} <Record_Components>
  token <end_token>
  token <end_record_token>
;

record_type_definition ::=
  token <abstract_token>
  token <tagged_token>
  token <limited_token>
  alt_record_definition <Record_Definition>
;

alt_record_definition ::= record_definition | null_record_definition;

scalar_constraint ::= range_constraint | digits_constraint | delta_constraint;

simple_expression_range ::=
  simple_expression <Lower_Bound>
  token <double_dot_token>
  simple_expression <Upper_Bound>
;

selected_component ::= prefix token <dot_token> selector_name <Selector>;

selected_identifier ::=
  program_unit_name <Prefix> token <dot_token> identifier <Selector>;

selector_name ::=
  identifier |
  enumeration_literal |
  operator_symbol;

short_circuit ::=
  expression <Short_Circuit_Operation_Left_Expression>
  token <and_token>
  token <then_token>
  expression <Short_Circuit_Operation_Right_Expression>;

signed_integer_type_definition ::=
  token <range_token>
  simple_expression_range <Integer_Constraint>
;

simple_expression ::=
    numeric_literal |
    null_literal |
    record_aggregate |
    extension_aggregate |
    name |
    qualified_expression |
    allocator |
    if_expression |
    case_expression |
    quantified_expression;

subtype_declaration ::=
  token <subtype_token>
  defining_identifier <Names>
  token <is_token>
  subtype_indication <Type_Declaration_View>
  {aspect_specification} <Aspect_Specifications>
  token <semicolon_token>
;

subtype_indication ::=
  token <not_token>
  subtype_mark
  constraint <Subtype_Constraint>;

subtype_indication_or_access_definition ::=
  subtype_indication | access_definition;

subtype_mark ::= identifier |
 selected_identifier;

subtype_mark_or_access_definition ::= subtype_mark | access_definition;

type_definition ::=
  enumeration_type_definition |
  signed_integer_type_definition |
  modular_type_definition |
  floating_point_definition |
  ordinary_fixed_point_definition |
  decimal_fixed_point_definition |
  unconstrained_array_definition |
  constrained_array_definition |
  record_type_definition |
  access_type_definition |
  derived_type_definition |
  derived_record_definition |
  interface_type_definition;

unconstrained_array_definition ::=
    token <array_token>
    token <left_token>
    {subtype_mark} <Index_Subtype_Definitions>
    token <right_token>
    token <of_token>
    component_definition <Array_Component_Definition>
;

unknown_discriminant_part ::=
    token <left_token>
    token <box_token>
    token <right_token>
;

use_clause ::= use_package_clause | use_type_clause;

use_package_clause ::=
  token <use_token>
  {program_unit_name} <Clause_Names>
  token <semicolon_token>
;

use_type_clause ::=
  token <use_token>
  token <all_token>
  token <type_token>
  {subtype_mark} <Type_Clause_Names>
  token <semicolon_token>
;

variant_part ::=
  token <case_token>
  identifier <Discriminant_Direct_Name>
  token <is_token>
  {variant} <Variants>
  token <end_token>
  token <end_case_token>
  token <semicolon_token>
;

variant ::=
  token <when_token>
  {discrete_choice} <Variant_Choices>
  token <arrow_token>
  {component_item} <Record_Components>
;

with_clause ::=
  token <limited_token>
  token <private_token>
  token <with_token>
  {program_unit_name} <Clause_Names>
  token <semicolon_token>
;


Synthesized attributes
  token  : Gela.Nodes.Token : self;

Synthesized attributes
  defining_identifier,
  identifier,
  program_unit_name,
  selected_identifier
  : Ada.Containers.Hash_Type : hash;

Rules for defining_identifier.identifier :
(.
      declare
         Token : constant Gela.Nodes.Token :=
           ${identifier.self};
           --  Self.Object.Identifier (Self.Payload);
         Comp  : constant Gela.Types.Compilation_Access :=
           Token.Object.Compilation (Token.Payload);
         Symbol : constant Gela.Types.Symbol :=
           Token.Object.Symbol (Token.Payload);
      begin
         ${defining_identifier.hash} := Ada.Containers.Hash_Type (Comp.Symbols.Value (Symbol).Hash);
      end;
.)

Rules for identifier.identifier :
(.
      declare
         Token : constant Gela.Nodes.Token :=
           ${identifier.self};
           --  Self.Object.Identifier (Self.Payload);
         Comp  : constant Gela.Types.Compilation_Access :=
           Token.Object.Compilation (Token.Payload);
         Symbol : constant Gela.Types.Symbol :=
           Token.Object.Symbol (Token.Payload);
      begin
         ${identifier.hash} := Ada.Containers.Hash_Type (Comp.Symbols.Value (Symbol).Hash);
      end;
.)

Rules for selected_identifier.identifier :
(.
      declare
         Left : constant Ada.Containers.Hash_Type :=
           ${Prefix.hash};
         Right : constant Ada.Containers.Hash_Type :=
           ${Selector.hash};
      begin
         ${selected_identifier.hash} := Join_Hash (Left, Right);
      end;
.)
